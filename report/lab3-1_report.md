# lab3-1实验报告

- 袁旷 PB17081543
- 李喆昊 PB17050941
- 杨舒静 PB17151774(队长)
## 实验要求

在本次实验运行`cminus_builder.cpp`将AST, 通过遍历各个结点，利用llvm c++ api转换为中间代码LLVM IR，并可以针对任意满足`C-`语法的输入程序生成可执行文件。助教完成的实验框架已经完成了将syntax_tree转换为c++中的树结构。主要部分即是遍历AST生成中间代码


## 实验难点
1. 理解代码框架，熟悉llvm c++ API
2. 如何设计全局变量
3. selection语句中由于产生新的`terminator`所产生的有关basic block的问题
4. 如何将数组传入函数中
5. 如何声明和访问全局变量

## 实验设计

### 一、对代码框架的理解
在本次实验运行`cminus_builder.cpp`将AST, 利用llvm c++ api转换为中间代码。
主类是`CminusBuilder`, 在`cminus_builder.hpp`中提供了一部分的generator代码可供参考。注意到，在该函数中即是一开始进入了全局范围。

#### 如何控制变量作用域(Scope函数)
Scope函数主要是用于维护不同作用域下的符号表。(具体接口`design.md`所示)

在本次实现维护该符号表的想法如下:
- 在有declaration时，CreateAlloca分配内存空间`pAlloc`
- 将`<id, pAlloc>`加入符号表
- 进入函数时`scope.enter()`
- 考虑到函数中存在嵌套调用的情况，需要在定义`Funcbb`后`scope.exit()`并将函数的二元组加入符号表供`call`调用
- 在函数结束时`scope.exit()`
其中对于数组类型，由于在数组越界的检查中只需检查下界而无需检查上界，因而只需要将`ArrayType`的值压入符号表即可

#### Accept函数
在访问者模式下，助教的框架已经构建好了AST, 同时在`transform`(`syntax_tree.cpp`文件)中已经将各个结构体的成员变量初始化完成。Accept函数中即是按照对AST的自顶向下遍历，对各个成员变量按照展开式语义进行操作, 如对于变量声明即是插入二元组进入符号表、调用子节点的accept函数等。


### 二、全局变量的设计
1. `Value* ret`
   
   对于`expression`型变量，将计算所得的值放入`ret`中， 待下一次需要用到的时候保存下来; 参照`syntax_call`中ret的使用
   
2. `Function *currentFunc`
   在处理selection语句、while循环语句以及处理数组的负的下标时，我们需要在当前LLVM IR代码中创建基本块`BasicBlock`，而`BasicBlock`的使用需要指定插入的函数。所以，我们利用全局变量`Function *currentFunc`来记录当前分析的函数，当分析到一个新的函数声明时就更新该全局变量。

3. `BasicBlock* expHandler;`

   若遇到使用负下标访问数组，则需要调用内置函数`void neg_idx_except(void)`来输出异常并终止程序。为保证程序简洁与基本块的格式正确，统一将同一函数内的输出异常与终止程序的操作放到 expHandler 中执行。

   一个函数共用 expHandler 基本块，在函数定义时该变量被初始化为空指针，若出现访问数组元素且该基本块未被创建（仍为空指针），那么创建该基本块。在处理fun-declaration 结点的末尾时，若发现 expHandler 指针不为空，那么插入该基本块，并插入输出异常和程序返回语句。

### 三、解决 selection-stmt 基本块创建的问题

在if-else分支中，如果两个分支中均有能被执行的`return`语句，那么不应该再创建跳出分支语句的`if_end`基本块。如果创建，则不仅会导致末尾的基本块中没有语句的情况，还会导致源基本块有多个终结语句，不符合 LLVM IR 基本块的语法。所以，我们需要根据分支的两个基本块中是否存在`return`语句来决定是否创建·`if_end`块以及是否跳转。

但是，仅仅判断 if 和 else 分支的入口基本块中是否存在`return`语句也是不够的，因为在分析 if 分支时，它其中可能还嵌套其他的控制流语句。在分析到 if 分支的末尾时，当前的插入点早已不在入口基本块中。正确的处理方法应该是判断 `builder.GetInsertBlock()->getTerminator() == nullptr`，即当前插入点所处的基本块是否存在终结语句，若不存在，创建 `if_end`基本块并跳转。这样的判断方法即保证了语义上能判断“分支中是否包含 return 语句”，又在语法上保证了每个基本块中有且仅有一个终结语句。

类似地，在处理 while 语句中基本块的跳转关系也是同样的判断方法。


### 实验总结
<!-- 此实验中有什么收获 -->
在本次实验中实践了中间代码生成的翻译方案，学习了`llvm`的接口。通过对每一条产生式进行分析，生成相应的中间代码，处理基本块创建以及数组越界等各种边界情况，不仅帮助我们熟悉了编译的流程，还提升了编程能力和团队协作能力，收获颇丰。


### 实验反馈

对本次实验的建议（可选 不会评分）
